#!/usr/bin/python
import os
import socket
import struct
import signal
from optparse import OptionParser

TC = '/usr/sbin/tc'
HASH_TABLE_START = 0x100
IPV4_SUBNET_PREFIX = '10.14'
DEBUG = False

class PolicyControl(object):
  interface = None

  # Level 2 hash tables
  tables = None
  next_table_id = HASH_TABLE_START
  l1_table = None

  # Filter rules
  filters = None

  def __init__(self, interface):
    """
    Class constructor.
    
    @param interface: Interface on which to operate
    """
    self.interface = interface
    self.tables = {}
    self.filters = {}

    # Create initial rules
    self.create_initial()

  def tc(self, command):
    """
    Executes a traffic control command.
    """
    if DEBUG:
      print "tc %s" % command

    #os.system('%s %s' % (TC, command))
  
  def remove_all_rules(self):
    """
    Removes all set stuff.
    """
    self.tc('qdisc del dev %s root handle 1: htb default 0' % self.interface)

  def get_hash_table_id(self):
    """
    Returns the next available hash table id and marks it as
    used.
    """
    hid = self.next_table_id
    self.next_table_id += 1
    return hid

  def create_initial(self):
    """
    Creates the initial rules.
    """
    # Initialize qdisc
    self.tc('qdisc add dev %s root handle 1: htb default 0' % self.interface)

    # Initialize L1 hash table
    l1_id = self.get_hash_table_id()
    self.tc('filter add dev %s parent 1: prio 1 handle %x: protocol ip u32 divisor 256' % (self.interface, l1_id))

    # L1 hash table lookup (IPv4) - destination address lives at offset 16
    l1_ht = 'filter add dev %s parent 1: prio 1 protocol ip u32 ht 800:: ' \
            'match ip dst %s.0.0/16 ' \
            'hashkey mask 0x0000ff00 at 16 ' \
            'link %x:' % (self.interface, IPV4_SUBNET_PREFIX, l1_id)
    self.tc(l1_ht)
    self.l1_table = l1_id

  def get_hash_keys(self, family, ip):
    """
    Computes the hash keys.

    @param family: Address family (4 for IPv4)
    @param ip: IP address
    @return: A tuple of L1 and L2 hash keys
    """
    if family == 4:
      raw = socket.inet_pton(socket.AF_INET, ip)
      return ord(raw[2]), ord(raw[3])
    elif family == 6:
      raise NotImplementedError
  
  def create_hash_table(self, l1, l2):
    """
    Creates a new level 2 hash table for filter lookups.

    @param l1: L1 hash key
    @param l2: L2 hash key
    """
    # Initialize L2 hash table
    l2_id = self.get_hash_table_id()
    self.tc('filter add dev %s parent 1: prio 1 handle %x: protocol ip u32 divisor 256' % (self.interface, l2_id))
    
    # L2 hash table lookup (IPv4)
    l2_ht = 'filter add dev %s parent 1: prio 1 protocol ip u32 ht %x:%x: ' \
            'match ip dst %s.%d.0/24 ' \
            'hashkey mask 0x000000ff at 16 ' \
            'link %x:' % (self.interface, self.l1_table, l1, IPV4_SUBNET_PREFIX, l1, l2_id)
    self.tc(l2_ht)

    # Register hash table
    self.tables[l1] = l2_id

  def insert_filter(self, family, ip, class_id):
    """
    Inserts a filter.

    @param family: Address family
    @param ip: Destination IP address
    @param class_id: Numeric class identifier
    """
    # Generate hash keys and create L2 table if one does not exist
    l1, l2 = self.get_hash_keys(family, ip)
    if l1 not in self.tables:
      self.create_hash_table(l1, l2)
    
    # Fetch L2 hash table identifier and priority
    l2_id = self.tables[l1]

    # Create filter
    self.tc('filter add dev %s parent 1: prio 1 protocol ip u32 ht %x:%x: ' \
            'match ip dst %s/32 ' \
            'flowid 1:%x' % (self.interface, l2_id, l2, ip, class_id))
    
    self.filters[family, ip] = class_id
  
  def update_filter(self, family, ip, class_id):
    """
    Updates an existing filter to point to a new class.

    @param family: Address family
    @param ip: Destination IP address
    @param class_id: Numeric class identifier
    """
    if (family, ip) not in self.filters:
      return self.insert_filter(family, ip, class_id)
    
    # Check if there are actually no changes
    if self.filters[family, ip] == class_id:
      return

    # Get hash keys so we know which filter to update
    l1, l2 = self.get_hash_keys(family, ip)
    l2_id = self.tables[l1]

    # Change filter
    self.tc('filter change dev %s parent 1: protocol ip prio 1 ' \
            'handle %x:%x:800 u32 flowid 1:%x' \
            % (self.interface, l2_id, l2, class_id))

    self.filters[family, ip] = class_id
  
  def remove_filter(self, family, ip):
    """
    Removes an existing filter.

    @param family: Address family
    @param ip: Destination IP address
    """
    if (family, ip) not in self.filters:
      return

    # Get hash keys so we know which filter to remove
    l1, l2 = self.get_hash_keys(family, ip)
    l2_id = self.tables[l1]

    # Remove filter
    self.tc('filter del dev %s parent 1: protocol ip prio 1 ' \
            'handle %x:%x:800 u32' \
            % (self.interface, l2_id, l2))

    del self.filters[family, ip]

  def insert_class(self, class_id, bandwidth):
    """
    Inserts a traffic control class.

    @param class_id: Numeric class identifier
    @parma bandwidth: Bandwidth limit in kbit/s
    """
    self.tc('class add dev %s parent 1: classid 1:%x htb rate %dkbit ceil %dkbit' \
            % (self.interface, class_id, bandwidth, bandwidth))
  
if __name__ == '__main__':
  print "============================================================================"
  print "                    wlan Ljubljana gateway policy daemon                    "
  print "============================================================================"

  if os.getuid() != 0:
    print "ERROR: Must be root to set policy!"
    exit(1)

  # Parse command line options
  parser = OptionParser()
  parser.add_option('-i', '--interface', dest = 'interface', help = 'Shaped interface')
  parser.add_option('-p', '--prefix', dest = 'prefix', help = 'Subnet prefix')
  parser.add_option('-d', '--debug', dest = 'debug', action = 'store_true', help = 'Output debug messages')
  options, args = parser.parse_args()
  options = options.__dict__
  
  for key in ('interface', 'prefix'):
    if not options[key]:
      print "ERROR: You must specify --interface and --prefix!"
      exit(1)

  DEBUG = options['debug']
  IPV4_SUBNET_PREFIX = options['prefix']
  p = PolicyControl(options['interface'])

  # Install signal handler for SIGTERM
  def handle_sigterm(signum, frame):
    raise KeyboardInterrupt

  signal.signal(signal.SIGTERM, handle_sigterm)
  
  try:
    p.insert_class(1, 512)
    p.insert_class(2, 1024)
    p.insert_class(3, 2048)
    p.insert_class(4, 4096)
    p.insert_filter(4, '10.14.128.1', 2)
    p.insert_filter(4, '10.14.128.33', 3)
    p.insert_filter(4, '10.14.129.129', 2)
    p.insert_filter(4, '10.14.130.33', 2)
    p.update_filter(4, '10.14.130.33', 3)
    p.remove_filter(4, '10.14.129.129')
  finally:
    p.remove_all_rules()

